class ecs/ComponentBody<ComponentBase>
{
    float size
}

class ecs/SystemResolveCollisions
{
    map<int, Observable<void(int target)>>:runtime:static event_collision

    fn void update(ModelEcsBase* model, float dt)
    {
        this->resole_collision_with_poly(model);

        int index = 0;
        model->each<ComponentBody, Transform>(
            [&](auto& body_a, auto& transform_a)
            {
                if(transform_a->z > 0)
                {
                    return;
                }
                for(int i=index+1; i<model->components_body.size(); ++i)
                {
                    auto body_b = model->components_body.at(i);
                    auto transform_b = model->get<Transform>(body_b->id);
                    if(transform_b->z > 0)
                    {
                        continue;
                    }
                    if(is_collision(transform_a, transform_b, body_a->size, body_b->size))
                    {
                        notify(transform_a->id, transform_b->id);
                        notify(transform_b->id, transform_a->id);
                        this->resole_collision(model, transform_a, transform_b, body_a->size, body_b->size);
                    }
                }
                ++index;
            }
            );
        // int count = list_size(model->components_transform);
        // for(int i=0; i<count-1; ++i)
        // {
        //     auto transform_a = model->components_transform[i];
        //     if(transform_a->z > 0)
        //     {
        //         continue;
        //     }
        //     float size_a = model->get<ComponentStats>(transform_a->id)->get(model, UnitStat::size);
        //     for(int k=i+1; k<count; ++k)
        //     {
        //         auto transform_b = model->components_transform[k];
        //         if(transform_b->z > 0)
        //         {
        //             continue;
        //         }
        //         float size_b = model->get<ComponentStats>(transform_b->id)->get(model, UnitStat::size);
        //         if(is_collision(transform_a, transform_b, size_a, size_b))
        //         {
        //             notify(transform_a->id, transform_b->id);
        //             notify(transform_b->id, transform_a->id);
        //             this->resole_collision(transform_a, transform_b, size_a, size_b);
        //         }
        //     }
        // }
    }

    fn void resole_collision_with_poly(ModelEcsBase* model)
    {
        model->each<ComponentBody, Transform, ComponentStats>(
            [&](auto& body, auto& transform, auto& stats)
            {
                auto size = stats->get(model, UnitStat::size);
                for(auto& polygon : model->ground->wall_polygons)
                {
                    Circle circle;
                    circle.center = transform->position;
                    circle.radius = stats->get(model, UnitStat::size);
                    auto collision = CollisionChecker::polygon_circle_mtv(polygon, circle);
                    if(collision.collision)
                    {
                        transform->position += collision.mtv;
                    }
                }
            });
    }

    fn void notify(int id, int target_id)
    {
        if(in_map(id, SystemResolveCollisions::event_collision))
        {
            SystemResolveCollisions::event_collision[id].notify(target_id);
        }
    }

    fn bool is_collision(Transform* a, Transform* b, float size_a, float size_b)
    {
        bool result = a->z == 0 && b->z == 0;
        result = result && (std::fabs(a->position.x - b->position.x) + std::fabs(a->position.y - b->position.y) < (size_a+size_b));
        result = result && a->position.get_distance_sq(b->position) < (size_a+size_b)*(size_a+size_b);
        return result;
    }
    fn bool is_collision(Transform* a, Transform* b, float size_a, float size_b, Vector:const:ref target_offset)
    {
        return a->z == 0 && b->z == 0 && a->position.get_distance_sq(b->position + target_offset) < (size_a+size_b)*(size_a+size_b);
    }
    fn void resole_collision(ModelEcsBase* model, Transform* transform_a, Transform* transform_b, float size_a, float size_b)
    {
        /*
        //TODO: враги застревают в стенах
        при расталкивании необходимо учитывать стены и отталкивать того, кто не уходит в стену
        */
        auto normal = transform_b->position - transform_a->position;
        normal.normalize(size_a + size_b);
        assert(std::fabs(normal.length() - (size_a + size_b)) < 1);
        auto pos = transform_a->position + normal;
        if(model->ground->is_bound(pos) && !model->ground->has_collision_with_walls(pos, size_b))
        {
            transform_b->position = pos;
        }
        else
        {
            transform_a->position = transform_b->position - normal;
        }
    }


    /*
    на будущее - если будет необходимость сделать разные типы земли (вода, стена), 
        то передавать в этот метод entity_id,
        брать из data или другого компонента возможность пересечения этого типа препятсвия.
        К примеру стрела может пролетать над землей, но не над стеной. 
        А баллистический снаряд может пролеть и там и там.
        Перс не может обойти оба эти препятствия
    */

    fn bool can_move(ModelEcsBase* model, int entity_id, Vector:ref:const pos, float radius):static
    {
        auto bullet = model->get<ComponentBullet>(entity_id);
        auto bullet_type = bullet ? bullet->bullet_type : BulletType::none;
        
        if(bullet_type == BulletType::none)
        {
            return !is_wall(model, entity_id, pos, radius);
        }
        else if(bullet_type == BulletType::arrow)
        {
            return bullet->through_walls || !is_wall(model, entity_id, pos, radius);
        }
        else if(bullet_type == BulletType::fireball)
        {
            return true;
        }
        else if(bullet_type == BulletType::balistic)
        {
            return true;
        }
        else 
        {
            assert(0);
        }
        return true;
    }

    fn bool is_wall(ModelEcsBase* model, int entity_id, Vector:ref:const pos, float radius):static
    {
        auto is_wall = model->ground->has_collision_with_walls(pos, radius);
        return is_wall;        
    }

    fn Vector find_collision_ray_and_walls(ModelEcsBase* model, Vector:ref:const ray_pos, Vector:ref:const ray_direction, float min_distance):static
    {
        Vector result;
        float min_dist = 99999;
        for(auto& polygon : model->ground->wall_polygons)
        {
            if(CollisionChecker::is_point_inside_polygon(ray_pos, polygon))
            {
                continue;
            }
            Ray ray(ray_pos, ray_direction);
            Vector point;
            if(!CollisionChecker::has_collision(ray, polygon, point))
            {
                continue;
            }
            auto len = (point-ray_pos).length();
            if(len < min_distance)
            {
                continue;
            }
            if(len < min_dist)
            {
                min_dist = len;
                result = point;
            }
        }
        return result;
    }

}
