
/*
летает возле игрока. их может быть несколько. Для этого нужна позиция. Делаю компонент, который хранит позиции всех духов
*/
class ecs/ComponentSpirit<ComponentBase>
{
    bool initialized = false
    float speed_random_t = 1
    Vector base_point
}
class ecs/ComponentSpiritBasePoints<ComponentBase>
{
    map<int, Vector> points
}
class ecs/ComponentSpawnSpirit<ComponentBase>
{
    DataUnit:link spirit
}

class ecs/SystemSpiritMovement
{
    fn void update(ModelEcsBase* model, float dt)
    {
        auto component_base = model->get<ComponentSpiritBasePoints>(model->player_id);
        auto player_transform = model->get<Transform>(model->player_id);
        model->each<ComponentSpirit, Transform>(
            [&](auto& spirit, auto& transform)
            {
                if(!spirit->initialized)
                {
                    this->initialize_spirit_points(model, component_base);
                }
                
                spirit->base_point.rotate(45 * M_PI / 180 * dt);
                auto offset = player_transform->position + spirit->base_point - transform->position;
                auto distance = offset.length();
                if(distance > 10)
                {
                    float speed = 50 + distance * spirit->speed_random_t;
                    offset /= distance;
                    transform->position += offset * dt * speed;
                }
            });
    }

    fn void initialize_spirit_points(ModelEcsBase* model, ComponentSpiritBasePoints* component_base)
    {
        auto size = static_cast<int>(model->components_spirit.size());
        auto points = this->generate_base_points(model, size);
        int i = 0;
        for(auto& spirit : model->components_spirit)
        {
            component_base->points[spirit->id] = points[i];
            if(!spirit->initialized)
            {
                spirit->speed_random_t = random_float() * 0.4f + 0.8f;
                assert(0.8f <= spirit->speed_random_t && spirit->speed_random_t <= 1.2f);
                spirit->initialized = true;
            }
            spirit->base_point = points[i];
            ++i;
        }
    }

    fn list<Vector> generate_base_points(ModelEcsBase* model, int count)
    {
        float base_angle = 270;
        float angle_on_one_spirit = 30;
        float half = (count - 1) / 2.f;
        float start_angle = base_angle - angle_on_one_spirit * half;
        std::vector<Vector> points;
        for(int i=0; i<count; ++i)
        {
            points.push_back(Vector::build_vector(start_angle * M_PI / 180) * 100);
            start_angle += angle_on_one_spirit;
        }
        return points;
    }
}

class ecs/SystemSpiritSpawn
{
    @include ComponentSpawnSpirit
    fn void update(ModelEcsBase* model, float dt)
    {
        while(!model->components_spawn_spirit.empty())
        {
            auto spawn = model->components_spawn_spirit.back();
            this->create_spirit(model, spawn);
            model->remove(spawn);
        }
    }

    fn void create_spirit(ModelEcsBase* model, ComponentSpawnSpirit* spawn)
    {
        auto transform = model->get<Transform>(model->player_id);
        auto id = BuilderEntity(spawn->spirit).set_position(transform->position).set_side(Side::ally).build(model);
        auto stats = model->get<ComponentStats>(id);
        stats->parent_id = model->player_id;
        model->event_create_entity.notify(id, transform->position);
    }
}