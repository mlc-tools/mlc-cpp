class ecs/ComponentHealingOnChangeMaxHp<ComponentBase>
{
    int current_max_hp
}

class ecs/ComponentDropHeart<ComponentBase>
{
}

class ecs/ComponentHeart<ComponentBase>
{
    bool clean = false
}

class ecs/ComponentHeartAddStats<ComponentBase>
{
    float percent = 1
    DataStatUpgrade:link stat_upgrade
}
class ecs/ComponentHeartAddStatsHp<ComponentHeartAddStats>{}
class ecs/ComponentHeartAddStatsDamage<ComponentHeartAddStats>{}

class ecs/ComponentRandomHealing<ComponentBase>
{
    float timer = 1
    float chance = 0.01
}

class ecs/ComponentVampire<ComponentBase>
{
    float chance = 0.1
    float heal_percent = 0.05
}

class ecs/SystemVampire
{
    fn void on_kill(ModelEcsBase* model, int killer_id, int target_id):static
    {
        auto component = model->get<ComponentVampire>(killer_id);
        if(!component)
        {
            return;
        }

        auto side_killer = model->get<ComponentSide>(killer_id);
        auto side_target = model->get<ComponentSide>(target_id);
        if(!side_killer || !side_target || !side_killer->is_enemy(side_target->side))
        {
            return;
        }

        if(random_float() < component->chance)
        {
            auto health = model->get<ComponentHealth>(killer_id);
            if(health && health->get_current() < health->max)
            {
                auto value = health->max * component->heal_percent;
                value = std::min(value, health->max - health->get_current());
                health->set_current(health->get_current() + value);
                model->event_healing[health->id].notify(value);
            }
        }
    }
}

class ecs/ComponentHealingLowHp<ComponentBase>
{
    float speed = 0.05
}

class ecs/SystemHealingOnChangeMaxHp
{
    fn void update(ModelEcsBase* model, float dt)
    {
        model->each_if<ComponentHealingOnChangeMaxHp,ComponentHealth, ComponentStats>(
            [&](auto& component_healing, auto& component_health, auto& stats)
            {
                component_health->max = stats->get(model, UnitStat::health);
                return component_healing->current_max_hp != static_cast<int>(component_health->max);
            },
            [&](auto& component_healing, auto& component_health, auto& stats)
            {
                if(component_healing->current_max_hp == 0 || component_healing->current_max_hp > component_health->max)
                {
                    component_healing->current_max_hp = component_health->max;
                    assert(component_healing->current_max_hp != 0);
                }

                float percent = component_health->get_current() / component_healing->current_max_hp;
                auto current = component_health->max * percent;
                auto add = current - component_health->get_current();
                if(add > 0)
                {
                    component_health->set_current(component_health->max * percent);
                    component_healing->current_max_hp = component_health->max;
                    //TODO: effect healing
                    model->event_healing[component_healing->id].notify(add);
                }

            });


        if(!model->wave_finished)
        {
            model->each_if<ComponentRandomHealing,ComponentHealth>(
            [&](auto& random_healing, auto& health)
            {
                random_healing->timer -= dt;
                return random_healing->timer <= 0 && health->get_current() < health->max;
            },
            [&](auto& random_healing, auto& health)
            {
                random_healing->timer = 1;
                if(random_float() < random_healing->chance)
                {
                    random_healing->chance = 0.f;
                    auto value = random_float() * 0.05f + 0.01f; //1-6%
                    value *= health->max;
                    value = std::min(health->max - health->get_current(), value);
                    health->set_current(health->get_current() + value);
                    //TODO: effect healing
                    model->event_healing[health->id].notify(value);
                }
                else
                {
                    random_healing->chance += 0.005f;
                    random_healing->chance = std::min(0.5f, random_healing->chance);
                }
            });

            model->each_if<ComponentHealingLowHp,ComponentHealth>(
            [&](auto& healing, auto& health)
            {
                return health->get_current() < health->max * 0.3f && health->get_current() > 0;
            },
            [&](auto& healing, auto& health)
            {
                auto limit = health->max * 0.3f;
                auto add = healing->speed * health->max * dt;
                add = std::min(limit - health->get_current(), add);
                if(add > 0)
                {
                    health->set_current(health->get_current() + add);
                    //TODO: effect healing
                    model->event_healing[health->id].notify(add);
                }
            });
        }
    }
}

class ecs/SystemDropHeart
{
    fn void update(ModelEcsBase* model, float dt)
    {
        model->each_if<ComponentDropHeart,ComponentHealth>(
            [&](auto& drop, auto& component_health)
            {
                return component_health->get_current() <= 0;
            },
            [&](auto& drop, auto& component_health)
            {
                auto chance = 0.1f;
                if(random_float() < chance)
                {
                    auto transform = model->get<Transform>(drop->id);
                    auto data = DataStorage::shared().get<DataUnit>("entity_heart");
                    auto id = BuilderEntity(data).set_side(mg::Side::ally).set_position(transform->position).build(model);
                    model->event_create_entity.notify(id, transform->position);                    
                }
            });

        auto player_transform = model->get<Transform>(model->player_id);
        auto dist = 100 * 100;
        model->each_if<ComponentHeart,Transform>(
            [&](auto& heart, auto& transform)
                {
                    return transform->position.get_distance_sq(player_transform->position) < dist;
                },
                [&](auto& heart, auto& transform)
                {
                    auto health = model->get<ComponentHealth>(model->player_id);
                    auto add = health->max * 0.25f;
                    add = std::min(add, health->max - health->get_current());
                    health->set_current(health->get_current() + add);

                    this->check_lucky_heart(model, model->get<ComponentHeartAddStatsHp>(model->player_id));
                    this->check_lucky_heart(model, model->get<ComponentHeartAddStatsDamage>(model->player_id));

                    heart->clean = true;
                });
        }
        fn void check_lucky_heart(ModelEcsBase* model, ComponentHeartAddStats* component)
        {
            auto player_stats = model->get<ComponentStats>(model->player_id);
            if(component && random_float() < component->percent)
            {
                player_stats->add_upgrade(component->stat_upgrade);
            }
        }
        fn void clean(ModelEcsBase* model)
        {
            list_do_if(model->components_heart, (component :> component->clean == true :> model->remove_entity(component->id)));
        }
}