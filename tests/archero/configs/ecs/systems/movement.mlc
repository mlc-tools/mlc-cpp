class ecs/ComponentMovement<ComponentBase>
{
    Vector direction
    ComponentAuraOfSlow* aura_slow = nullptr
    float slow_k = 1
}
class ecs/MoveDirection<ComponentMovement>
{
    bool clean = false
}
class ecs/MoveToTarget<ComponentMovement>
{
    int target_id
    Vector offset
    Vector changed_direction
    float timer_to_move_by_changed_direction
}
class ecs/MoveInstant<ComponentMovement>
{
    int target_id
}
class ecs/MoveVertical<ComponentMovement>
{
    Vector destination
    float start_z = 10
    float duration = 0.66
    float timer = 0
    bool done = false
}
class ecs/Freezing<ComponentBase>
{
    bool activated = false
    float life_time = 0
    float duration = 0
    float damage = 0
}

class ecs/MoveParabolic<ComponentBase>
{
    Vector:private start_position
    Vector:private target_position
    Vector:private offset
    float:private height
    float:private timer
    float:private duration
    bool done = false
    float z

    fn float get_duration():const
    {
        return this->duration;
    }
    fn float get_height():const
    {
        return this->height;
    }

    fn void set(Vector:ref:const start_position, Vector:ref:const target_position, float speed)
    {
        this->start_position = start_position;
        this->target_position = target_position;
        this->offset = target_position - start_position;
        auto dist = offset.length();
        this->height = dist / 3;
        this->duration = dist / speed;
    }

    fn Vector update_position(float dt)
    {
        this->timer = std::min(this->timer + dt, this->duration);
        auto t = this->timer / this->duration;
        if(t >= 1)
        {
            t = 1;
            this->done = true;
        }
        auto result = start_position + offset * t;

        this->z = sin(M_PI * t) * this->height;

        return result;
    }
}

class ecs/ComponentCreateMovementToHero<ComponentBase>
{
}


class ecs/SystemCreateMovement
{
    fn void update(ModelEcsBase* model, float dt)
    {
        model->each_if<ComponentCreateMovementToHero, ComponentBusy>(
            [&](auto& component, auto& busy)
            {
                return !busy->is_busy;
            },
            [&](auto& component, auto& busy)
            {
                auto movement = model->get<MoveToTarget>(component->id);
                if(movement)
                {
                    return;
                }
                movement = new MoveToTarget();
                movement->target_id = model->player_id;
                model->add(movement, component->id);
            });
    }
}

class ecs/SystemMovement
{
    @include MoveDirection
    @include MoveToTarget

    map<int, Observable<void()>>:runtime:static event_on_wall

    fn void update(ModelEcsBase* model, float dt)
    {
        this->move_by_direction(model, dt);
        this->move_to_target(model, dt);
        this->move_by_parabolic(model, dt);
        this->move_instant(model, dt);
        this->move_vertical(model, dt);
    }
    fn void clean(ModelEcsBase* model)
    {
        model->each_if<MoveDirection, Transform>(
            [&](auto& move, auto& transform)
            { 
                return !model->ground->is_bound(transform->position);
            },
            [&](auto& move, auto& transform)
            {
                move->clean = true;
            });

        list_do_if(model->components_move_direction, (component :> component->clean :> model->remove_entity(component->id)));
    }

    fn void move_by_direction(ModelEcsBase* model, float dt)
    {
        model->each<MoveDirection, ComponentStats, Transform>(
            [&](auto& move, auto& stats, auto& transform)
            {
                auto speed = stats->get(model, UnitStat::speed);
                auto offset = move->direction * (dt * speed);
                this->move(model, move, transform, stats, offset);
            });
    }
    fn void move_to_target(ModelEcsBase* model, float dt)
    {
        model->each<MoveToTarget, ComponentStats, Transform>(
            [&](auto& move, auto& stats, auto& transform)
            {
                auto speed = stats->get(model, UnitStat::speed);
                
                //сталкивался ранее со стеной - идет в другом направлении по таймеру
                if(move->timer_to_move_by_changed_direction > 0)
                {
                    move->timer_to_move_by_changed_direction -= dt;
                    auto offset = move->changed_direction * (dt * speed);
                    this->move(model, move, transform, stats, offset);
                }
                else
                {
                    auto target_transform = model->get<Transform>(move->target_id);
                    if(target_transform)
                    {
                        auto pos = target_transform->position + move->offset;
                        auto dir = pos - transform->position;
                        dir.normalize();
                        auto offset = dir * (dt * speed);
                        
                        // если столкнулся со стеной
                        if(!this->move(model, move, transform, stats, offset))
                        {
                            move->timer_to_move_by_changed_direction = 1;
                            move->changed_direction = Vector::generate_random_point_on_radius(1) + dir.normalize();
                            move->changed_direction.normalize();
                        }
                        else
                        {
                            move->direction = dir;
                        }
                    }
                }
            });
    }
    fn void move_by_parabolic(ModelEcsBase* model, float dt)
    {
        model->each<MoveParabolic, ComponentStats, Transform>(
            [&](auto& move, auto& stats, auto& transform)
            {
                auto pos = move->update_position(dt);
                transform->position = pos;
                transform->z = move->z;
            });
    }
    fn void move_instant(ModelEcsBase* model, float dt)
    {
        model->each<MoveInstant, Transform>(
            [&](auto& move, auto& transform)
            {
                auto transform_target = model->get<Transform>(move->target_id);
                if(transform_target)
                {
                    transform->position = transform_target->position;
                }
            });
    }
    fn void move_vertical(ModelEcsBase* model, float dt)
    {
        model->each<MoveVertical, Transform>(
            [&](auto& move, auto& transform)
            {
                move->timer += dt;
                float t = move->duration - move->timer;
                float z = move->start_z * t;
                transform->z = z;
                if(t <= 0)
                {
                    move->done = true;
                }
            });
    }

    fn bool move(ModelEcsBase* model, ComponentMovement* movement, Transform* transform, ComponentStats* stats, Vector:ref:const offset)
    {
        if(auto stun = model->get<ComponentStun>(movement->id))
        {
            if(stun->activated)
            {
                return false;
            }
        }
        auto move_offset = offset * movement->slow_k;
        auto new_pos =  transform->position + move_offset;
        bool can = true;
        Vector wall_normal;
        bool has_wall_collision = false;

        {
            bool slide_handled = false;
            auto body = model->get<ComponentBody>(transform->id);
            float radius = body ? body->size : 20;
            for(auto& polygon : model->ground->wall_polygons)
            {
                auto collision = CollisionChecker::polygon_circle_mtv(polygon, Circle(new_pos, radius));
                if(collision.collision)
                {
                    wall_normal = collision.mtv;
                    wall_normal.normalize();
                    has_wall_collision = true;
                    auto tangent = move_offset - wall_normal * move_offset.dot(wall_normal);
                    if(tangent.length() > 0)
                    {
                        tangent.normalize(move_offset.length());
                        auto slide_pos = transform->position + tangent;
                        if(SystemResolveCollisions::can_move(model, transform->id, slide_pos, stats->get(model, UnitStat::size)))
                        {
                            transform->set(slide_pos);
                            slide_handled = true;
                            can = false;
                        }
                    }
                    break;
                }
            }
            if(!slide_handled)
            {
                can = SystemResolveCollisions::can_move(model, transform->id, new_pos, stats->get(model, UnitStat::size));
            }
            if(!can && !slide_handled)
            {
                auto offset_length = move_offset.length();
                float sx = move_offset.x < 0 ? -1 : 1;
                float sy = move_offset.y < 0 ? -1 : 1;
                if(SystemResolveCollisions::can_move(model, transform->id, Vector(transform->position.x + offset_length * sx, transform->position.y), stats->get(model, UnitStat::size)))
                {
                    transform->set(Vector(transform->position.x + offset_length * sx, transform->position.y));
                }
                else if(SystemResolveCollisions::can_move(model, transform->id, Vector(transform->position.x, transform->position.y + offset_length * sy), stats->get(model, UnitStat::size)))
                {
                    transform->set(Vector(transform->position.x, transform->position.y + offset_length * sy));
                }
            }
        }

        if(!can && in_map(transform->id, SystemMovement::event_on_wall))
        {
            SystemMovement::event_on_wall[transform->id].notify();
        }

        if(can)
        {
            transform->set(new_pos);
            return true;
        }
        else
        {
            auto bullet = model->get<ComponentBullet>(transform->id);
            if(bullet && bullet->ricochet_wall > 0 && has_wall_collision)
            {
                --bullet->ricochet_wall;
                bullet->damage *= 0.5f;
                transform->prev_position = transform->position;
                auto dir = movement->direction;
                dir = dir - wall_normal * 2 * dir.dot(wall_normal);
                dir.normalize();
                if(auto move_dir = model->get<MoveDirection>(transform->id))
                {
                    move_dir->direction = dir;
                }
                else if(auto move_to = model->get<MoveToTarget>(transform->id))
                {
                    model->remove(move_to);
                    auto md = new MoveDirection();
                    md->direction = dir;
                    model->add(md, transform->id);
                }
                return true;
            }
            if(bullet)
            {
                bullet->clean = true;
            }
            return false;
        }
    }
}

class ecs/ComponentPush<ComponentBase>
{
    Vector direction
    float duration = 0.1
    float speed
}

class ecs/SystemPush
{
    fn void update(ModelEcsBase* model, float dt)
    {
        model->each<ComponentPush, Transform, ComponentStats>(
            [&](auto& push, auto& transform, auto& stats)
            {
                push->duration -= dt;
                auto resist = stats->get(model, UnitStat::push_target_resist);
                if(resist >= 1)
                {
                    return;
                }
                auto offset = push->direction * (dt * push->speed) * (1-resist);
                auto new_pos =  transform->position + offset;
                auto can = SystemResolveCollisions::can_move(model, transform->id, new_pos, stats->get(model, UnitStat::size));
                if(can)
                {
                    transform->set(new_pos);
                }
            });
    }
    fn void clean(ModelEcsBase* model)
    {
        list_do_if(model->components_push, (push :> push->duration <= 0 :> model->remove(push)));
    }
}
class ecs/SystemFreezing
{
    fn void add_damage(ModelEcsBase* model, int target_id, ComponentStats* target_stats, float damage):static
    {
        auto freeze = model->get<Freezing>(target_id);
        if(!freeze)
        {
            freeze = new Freezing();
            model->add(freeze, target_id);
        }
        if(freeze->activated || freeze->life_time > 0)
        {
            return;
        }

        if(target_stats)
        {
            auto resist = target_stats->get(model, UnitStat::freezing_resist);
            damage *= (1 - resist);
        }

        freeze->damage += damage;
        if(freeze->damage >= 1 && target_stats)
        {
            freeze->activated = true;
            freeze->duration = 2;
            auto freeze_immunity_time = target_stats->get(model, UnitStat::freeze_immunity_time);
            freeze->life_time = freeze->duration + freeze_immunity_time;
            target_stats->set_fixed(UnitStat::speed, 0.01);
            target_stats->set_fixed(UnitStat::recharge, 9999);
            model->event_freeze_activated[target_id].notify();
        }
    }

    fn void update(ModelEcsBase* model, float dt)
    {
        model->each<Freezing, ComponentStats>(
            [&](auto& freeze, auto& stats)
            {
                if(freeze->activated)
                {
                    freeze->duration -= dt;
                    freeze->life_time -= dt;
                    if(freeze->duration <= 0)
                    {
                        freeze->activated = false;
                        stats->reset_cashe(UnitStat::speed);
                        stats->reset_cashe(UnitStat::recharge);
                        freeze->damage = 0;
                        model->event_freeze_deactivated[freeze->id].notify();
                    }
                }
                else if(freeze->life_time > 0)
                {
                    freeze->life_time -= dt;
                    if(freeze->life_time < 0)
                    {
                        freeze->life_time = 0;
                    }
                }
            });
    }
}
