class ecs/ActionMoveDirection<ActionBase>
{
    // bool finish_on_wall = true
    fn void on_start()
    {
        auto movement = new MoveDirection();
        movement->direction = this->choose_direction();
        model->add(movement, this->entity_id);
        this->common_dictionary->vectors["move_direction"] = movement->direction;

        SystemMovement::event_on_wall[this->entity_id].add(this, [this]()
        {
            auto movement = this->model->get<MoveDirection>(this->entity_id);
            if(movement)
            {
                auto r = random_int(0, 3);
                if(r == 0)
                {
                    movement->direction.x = -movement->direction.x;
                }
                else if(r == 1)
                {
                    movement->direction.y = -movement->direction.y;
                }
                else if(r == 2)
                {
                    movement->direction = -movement->direction;
                }
            }
            else
            {
                this->_finished = true;
            }
            // auto movement = this->model->get<MoveDirection>(this->entity_id);
            // if(movement)
            // {
            //     movement->direction = this->choose_direction();
            // }
            // else
            // {
            //     this->_finished = true;
            // }
        });
    }
    fn void on_update(float dt)
    {
    }
    fn void on_break()
    {
        model->remove(model->get<MoveDirection>(this->entity_id));
    }
    fn void on_finish()
    {
        model->remove(model->get<MoveDirection>(this->entity_id));

        map_remove(SystemMovement::event_on_wall, this->entity_id);
    }

    fn Vector choose_direction():virtual
    {
        Vector direction;
        direction.x = random_float() * 2 - 1;
        direction.y = random_float() * 2 - 1;
        direction.normalize();
        return direction;
    }
}
class ecs/ActionMoveToCenterHorizontalOrVertical<ActionMoveDirection>
{
    fn Vector choose_direction()
    {
        auto transform = model->get<Transform>(this->entity_id);
        auto center = model->ground->get_center_position();
        Vector direction;
        auto rand = random_int(0, 2);
        if(rand == 0)
        {
            if(transform->position.x < center.x) direction.x = 1;
            else direction.x = -1;
        }
        else
        {
            if(transform->position.y < center.y) direction.y = 1;
            else direction.y = -1;
        }
        return direction;
    }
}

class ecs/ActionHorizontalOrVerticalOrDiagonal<ActionMoveToCenterHorizontalOrVertical>
{
    fn Vector choose_direction()
    {
        Vector direction;
        direction.x = random_int(0, 3) - 1;
        direction.y = random_int(0, 3) - 1;
        direction.normalize();
        return direction;
    }
}

class ecs/ActionRunToPlayer<ActionBase>
{
    string animation = "run"
    fn void on_start()
    {
        auto transform = model->get<Transform>(this->entity_id);
        auto transform_hero = model->get<Transform>(model->player_id);
        auto direction = transform_hero->position - transform->position;

        auto movement = new MoveDirection();
        movement->direction = direction;
        movement->direction.normalize();
        model->add(movement, this->entity_id);

        auto stats = model->get<ComponentStats>(this->entity_id);
        auto buf = DataStorage::shared().get<DataStatUpgrade>("enemy_skill_run_add_speed");
        stats->add_upgrade(buf);

        model->get<ComponentBusy>(this->entity_id)->is_busy = true;
        model->event_turn_to[this->entity_id].notify(model->player_id);
        model->event_skill_animate[this->entity_id].notify(this->animation, true);

        SystemResolveCollisions::event_collision[this->entity_id].add(this, [this](int target_id)
        {
            if(target_id == model->player_id)
            {
                // столкнулся с игроком. Запускаю дамаг, уменьшение времени скила
                this->_breaked = true;
            }
        });
        SystemMovement::event_on_wall[this->entity_id].add(this, [this]()
        {
            this->_finished = true;
        });
    }
    fn void on_update(float dt)
    {
    }
    fn void on_break()
    {
        // damage hero
        this->finalize();
        this->set_next_action(this->next_action_on_break);
    }
    fn void on_finish()
    {
        // wait after run
        this->finalize();
        this->set_next_action(this->next_action_on_finish);
    }
    fn void finalize()
    {
        model->remove(model->get<MoveDirection>(this->entity_id));

        auto stats = model->get<ComponentStats>(this->entity_id);
        auto buf = DataStorage::shared().get<DataStatUpgrade>("enemy_skill_run_add_speed");
        stats->remove_upgrade(buf);

        model->get<ComponentBusy>(this->entity_id)->is_busy = false;

        map_remove(SystemResolveCollisions::event_collision, this->entity_id);
        map_remove(SystemMovement::event_on_wall, this->entity_id);
    }
}

class ecs/ActionMoveToPlayer<ActionBase>
{
    fn void on_start()
    {
        auto movement = new MoveToTarget();
        movement->target_id = model->player_id;
        model->add(movement, this->entity_id);

        SystemResolveCollisions::event_collision[this->entity_id].add(this, [this](int target_id)
        {
            if(target_id == model->player_id)
            {
                this->_breaked = true;
            }
        });
        // SystemMovement::event_on_wall[this->entity_id].add(this, [this]()
        // {
        //     this->_finished = true;
        // });
    }
    fn void on_update(float dt)
    {
    }
    fn void on_break()
    {
        // damage hero
        this->finalize();
        this->set_next_action(this->next_action_on_break);
    }
    fn void on_finish()
    {
        // wait after run
        this->finalize();
        this->set_next_action(this->next_action_on_finish);
    }
    fn void finalize()
    {
        model->remove(model->get<MoveToTarget>(this->entity_id));

        map_remove(SystemResolveCollisions::event_collision, this->entity_id);
        map_remove(SystemMovement::event_on_wall, this->entity_id);
    }
}