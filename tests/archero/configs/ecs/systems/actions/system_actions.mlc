class ecs/Dictionary
{
    map<string, string> strings
    map<string, Vector> vectors
}

class ecs/ComponentActions<ComponentBase>
{
    bool initialized = false

    list<ActionBase*>:private actions
    map<string, ActionBase*>:private map_actions
    ActionBase* current_action
    string first_action
    string next_action

    Dictionary* dictionary

    fn ActionBase* get_action(string name)
    {
        return this->map_actions.at(name);
    }

    fn void initialize(ModelEcsBase* model, int entity_id)
    {
        assert(!this->initialized);
        this->initialized = true;

        this->dictionary = new Dictionary();

        assert(this->map_actions.size() == 0);
        for(auto& action : this->actions)
        {
            action->model = model;
            action->entity_id = entity_id;
            action->common_dictionary = this->dictionary;

            if(action->random_duration)
            {
                action->duration += random_float() * action->random_duration;
            }

            this->map_actions[action->name] = action;
        }
        this->first_action = this->actions[0]->name;
    }
}


class ecs/ActionBase
{
    ModelEcsBase* model
    int entity_id
    float duration = 0
    float random_duration = 0
    float timer = 0
    string name

    Dictionary* common_dictionary
    
    string:protected next_action_on_break
    string:protected next_action_on_finish
    string:protected next_action
    bool:protected _finished = false
    bool:protected _breaked = false

    string switch_to_action

    fn bool is_finished():const
    {
        return this->_finished;
    }
    fn bool is_breaked():const
    {
        return this->_breaked;
    }
    // Call from system
    fn void start()
    {
        this->_finished = false;
        this->_breaked = false;
        this->timer = 0;
        this->on_start();
    }
    fn void update(float dt)
    {
        if(duration > 0)
        {
            this->timer += dt;
            if(this->timer >= this->duration)
            {
                this->_finished = true;
                this->set_next_action(this->next_action_on_finish);
            }
        }
        this->on_update(dt);
    }
    fn void break_()
    {
        this->on_break();
    }
    fn void finish()
    {
        this->on_finish();
    }

    // to override on other actions
    fn void on_start():virtual:protected
    {

    }
    fn void on_update(float dt):virtual:protected
    {

    }
    fn void on_break():virtual:protected
    {

    }
    fn void on_finish():virtual:protected
    {
        
    }

    fn void set_next_action(string action)
    {
        if(string_size(action) > 0)
        {
            this->switch_to_action = action;
        }
        else
        {
            this->switch_to_action = next_action;
        }
        assert(string_size(this->switch_to_action) > 0);
    }

    fn void check_duration(string animation)
    {
        if(!animation.empty())
        {
            if(this->duration == 0)
            {
                this->duration = model->get<ComponentSpineInfo>(this->entity_id)->get_animation_duration(animation);
            }
        }

    }
}

class ecs/SystemActions
{
    fn void update(ModelEcsBase* model, float dt)
    {
        for(auto component : model->components_actions)
        {
            if(!component->initialized)
            {
                component->initialize(model, component->id);
            }
            if(component->current_action == nullptr)
            {
                this->switch_to_next(model, component);
            }

            
            if(auto stun = model->get<ComponentStun>(component->id))
            {
                if(stun->activated)
                {
                    continue;
                }
            }
            
            component->current_action->update(dt);
            
            if(component->current_action->is_finished())
            {
                component->current_action->finish();
                component->next_action = component->current_action->switch_to_action;
                component->current_action = nullptr;
            }
            else if(component->current_action->is_breaked())
            {
                component->current_action->break_();
                component->next_action = component->current_action->switch_to_action;
                component->current_action = nullptr;
            }
        }
    }
    fn void switch_to_next(ModelEcsBase* model, ComponentActions* component)
    {
        assert(component->current_action == nullptr);

        if(string_size(component->next_action) == 0)
        {
            component->next_action = component->first_action;
        }
        component->current_action = component->get_action(component->next_action);
        component->current_action->start();
    }
}