class ecs/ComponentMeteorPeriodic<ComponentBase>
{
    float period = 3
    float timer = 0
}

class ecs/SystemMeteor
{
    fn void update(ModelEcsBase* model, float dt)
    {
        this->dispatch_periodic_meteor(model, dt);
    }

    fn void dispatch_periodic_meteor(ModelEcsBase* model, float dt)
    {
        model->each<ComponentMeteorPeriodic, Transform>(
            [&](auto& component, auto& transform)
            {
                component->timer -= dt;
                if(component->timer <= 0)
                {
                    component->timer = component->period;
                    auto target_id = SystemMeteor::get_random_enemy(model, component->id);
                    if(target_id > 0)
                    {
                        auto stats = model->get<ComponentStats>(component->id);
                        int count = 1 + stats->get(model, UnitStat::meteor_count);
                        SystemMeteor::create_meteor(model, component->id, count, target_id);
                    }
                }
            });
    }

    fn void create_meteor(ModelEcsBase* model, int shooter_id, int count, int target_id):static
    {
        for(int i = 0; i < count; ++i)
        {
            int current_target = target_id;
            if(current_target <= 0 || i > 0)
            {
                current_target = SystemMeteor::get_random_enemy(model, shooter_id);
            }
            if(current_target <= 0)
            {
                continue;
            }
            auto target_transform = model->get<Transform>(current_target);
            auto start_pos = target_transform->position;
            BuilderBullet(shooter_id)
                .set_name("meteor")
                .set_target_id(current_target)
                .set_position_create(start_pos)
                .set_position_to_shoot(target_transform->position)
                .build(model);
        }
    }

    fn int get_random_enemy(ModelEcsBase* model, int shooter_id):static
    {
        auto side_shooter = model->get<ComponentSide>(shooter_id);
        std::vector<int> enemies;
        model->each<ComponentSide, ComponentHealth>(
            [&](auto& side, auto& health)
            {
                if(side_shooter->is_enemy(side->side) && health->get_current() > 0)
                {
                    enemies.push_back(side->id);
                }
            });
        if(enemies.empty())
        {
            return 0;
        }
        auto index = random_int(0, enemies.size());
        return enemies[index];
    }
}
