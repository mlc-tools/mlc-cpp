interface ecs/IControllerDungeonBase:virtual
{


}

class ecs/ControllerDungeonBase<IControllerDungeonBase>:virtual:prefer_use_forward_declarations
{
    @include ComponentSide
    @include SpawnInfo
    @include ComponentSpirit

    ModelEcsBase* model
    int paused = false
    int wave_counter = 0
    bool show_window_skill = false
    bool run_next_wave = false

    fn void pause()
    {
        paused += 1;
    }
    fn void resume()
    {
        paused -= 1;
    }

    fn bool is_level_finished()
    {
        return this->model->wave_index >= this->model->data->waves.size() && this->is_wave_finished();
    }
    fn bool is_wave_finished()
    {
        if(model->components_spawn.size() > 0)
        {
            return false;
        }
        for(auto component : model->components_side)
        {
            if(component->side == Side::enemy)
            {
                return false;
            }
        };

        if(model->wave_index > 0 && model->wave_index-1 < list_size(model->data->waves))
        {
            auto wave_generator = model->data->waves.at(model->wave_index-1);
            if(wave_generator->is_interval_generate())
            {
                return wave_generator->is_finished(model);
            }
        }

        model->wave_finished = true;
        return true;
    }

    fn void update(float dt)
    {

        if(is_level_finished())
        {
            return;
        }
        if(this->paused == 0 && dt > 0)
        {
            model->update(dt);
        }


        if(this->paused == 0 && is_wave_finished() == true && !this->show_window_skill)
        {
            if(!model->data->is_change_view_on_next_wave())
            {
                generate_wave();
            }
            else if(model->data->is_change_view_on_next_wave() && model->components_gate.size() == false && !run_next_wave && model->spawn_points.count("gate") > 0)
            {
                this->create_gate_to_next_wave();
            }
            else
            {
                generate_wave();
            }
        }

        auto wave_generator = model->data->waves.at(model->wave_index-1);
        if(wave_generator->is_interval_generate() && !this->show_window_skill)
        {
            if(!wave_generator->is_finished(model) && wave_generator->update(model, dt))
            {
                this->generate_units_on_wave();
            }
        }
        
    }

    fn void create_hero()
    {
        auto data = DataStorage::shared().get<DataUnit>("hero_survival");
        auto pos = model->spawn_points.at("hero");
        model->player_id = BuilderEntity(data).set_position(pos).set_side(Side::ally).set_user(model->user).build(model);
        model->event_create_entity.notify(model->player_id, pos);
    }

    fn void create_gate_to_next_wave()
    {
        auto data = DataStorage::shared().get<DataUnit>("entity_gate_to_next_wave");
        auto pos = model->spawn_points.at("gate");
        auto id = BuilderEntity(data).set_position(pos).set_side(Side::ally).build(model);
        model->event_create_entity.notify(id, pos);
    }

    fn void generate_wave()
    {
        map_clear(SystemResolveCollisions::event_collision);
        map_clear(SystemMovement::event_on_wall);

        ++model->wave_index;
        this->model->data->waves.at(model->wave_index-1)->on_start(this->model);
        this->generate_units_on_wave();
        
        model->wave_finished = false;
        model->event_wave_start.notify();
    }

    fn void generate_units_on_wave()
    {
        assert(model->wave_index > 0 && model->wave_index-1 < list_size(model->data->waves));
        auto wave_spawn = model->data->waves.at(model->wave_index-1);
        auto spawns = wave_spawn->get_units(model);
        for(auto& spawn : spawns)
        {
            this->create_enemy(spawn.unit, spawn.position, 1);
        }
    }

    fn void create_enemy(DataUnit:link unit, Vector:ref:const pos, int level)
    {
        auto spawn = new ComponentSpawn();
        spawn->unit = unit;
        spawn->position = pos;
        model->add(spawn, model->get_free_id());
    }

    fn void add_skill(DataStatUpgrade:link skill)
    {
        if(!skill->to_spirits)
        {
            add_skill_to_entity(skill, this->model->player_id);
        }
        else
        {
            this->model->each<ComponentSpirit>([&](auto& spirit)
            {
                add_skill_to_entity(skill, spirit->id);
            });
        }
        this->model->has_skills[skill] = 1;
    }
    fn void add_skill_to_entity(DataStatUpgrade:link skill, int entity_id)
    {
        auto stats = this->model->get<ComponentStats>(entity_id);
        stats->add_upgrade(skill);
        for(auto& component : skill->components)
        {
            auto clone = clone_object<ComponentBase>(component);
            clone->id = entity_id;
            clone->add_self_to_model(model);
        }
    }

    fn list<DataStatUpgrade:link> generate_skills(int count)
    {
        // return
        // {
        //     DataStorage::shared().get<DataStatUpgrade>("sphere_fire"),
        //     DataStorage::shared().get<DataStatUpgrade>("sphere_electric"),
        //     DataStorage::shared().get<DataStatUpgrade>("sphere_saw"),
        // };

        auto params = DataStorage::shared().get<DataParams>(DataParams::DEFAULT);
        auto rarity = Shuffle::shuffle(params->skill_rarity_weights);
        std::vector<const DataStatUpgrade*> skills;
        std::vector<const DataStatUpgrade*> result;
        for(auto&& [name, data] : DataStorage::shared().get_stat_upgrades())
        {
            if(data.rarity == rarity && !in_map(&data, this->model->has_skills))
            {
                skills.push_back(&data);
            }
        }

        while(count-- > 0)
        {
            auto i = random_int(0, static_cast<int>(skills.size()));
            result.push_back(skills[i]);
            list_erase(skills, i);
        }
        return result;
    }
}