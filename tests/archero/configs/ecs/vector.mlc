class ecs/Vector
{
    float:const:static FLOAT_SMALL = 2e-37f
    Vector:const:static ZERO
    float x = 0
    float y = 0

    constructor(float x=0, float y=0)
    {
        this->x = x;
        this->y = y;
    }


    fn Vector operator-():const:cpp
    {
        return Vector(-this->x, -this->y);
    }

    fn Vector operator+(Vector:ref:const v):const:cpp
    {
        return Vector(this->x + v.x, this->y + v.y);
    }
    fn Vector operator-(Vector:ref:const v):const:cpp
    {
        return Vector(this->x - v.x, this->y - v.y);
    }
    fn Vector operator*(float v):const:cpp
    {
        return Vector(this->x * v, this->y * v);
    }
    fn Vector operator/(float v):const:cpp
    {
        if(std::fabs(v) > FLOAT_SMALL)
        {
            auto inv = 1.f / v;
            return Vector(this->x * inv, this->y * inv);
        }
        else
        {
            assert(false);
            return Vector(0.f, 0.f);
        }
    }

    fn Vector:ref operator+=(Vector:ref:const v):cpp
    {
        this->x += v.x;
        this->y += v.y;
        return *this;
    }
    fn Vector:ref operator-=(Vector:ref:const v):cpp
    {
        this->x -= v.x;
        this->y -= v.y;
        return *this;
    }
    fn Vector:ref operator*=(float v):cpp
    {
        this->x *= v;
        this->y *= v;
        return *this;
    }
    fn Vector:ref operator/=(float v):cpp
    {
        if(std::fabs(v) > 0.000001f)
        {
            auto inv = 1.f / v;
            this->x *= inv;
            this->y *= inv;
        }
        else
        {
            assert(false);
            this->x = 0;
            this->y = 0;
        }
        return *this;
    }

    fn float dot(Vector:const:ref v):const
    {
        return this->x * v.x + this->y * v.y;
    }

    fn float length():const
    {
        return std::sqrt(x*x + y*y);
    }
    fn float length_sq():const
    {
        return x*x + y*y;
    }

    fn Vector:ref normalize(float desired_length=1)
    {
        assert(std::fabs(desired_length) > FLOAT_SMALL);

        auto len = this->length();
        if(len > FLOAT_SMALL)
        {
            auto scale = desired_length / len;
            this->x *= scale;
            this->y *= scale;
        }
        else
        {
            this->x = desired_length;
            this->y = 0;
        }
        return *this;
    }

    fn Vector get_normalized():const
    {
        Vector v = *this;
        v.normalize();
        return v;
    }

    fn float get_distance(Vector:ref:const v):const
    {
        return std::sqrt(this->get_distance_sq(v));
    }
    fn float get_distance_sq(Vector:ref:const v):const
    {
        float x = v.x - this->x;
        float y = v.y - this->y;
        return x*x + y*y;
    }

    fn void rotate(float radians)
    {
        float x = this->x * cos(radians) - this->y * sin(radians);
        float y = this->x * sin(radians) + this->y * cos(radians);
        this->x = x;
        this->y = y;
    }

    fn Vector get_normal_to(Vector:const:ref vector):static
    {
        Vector normal(-vector.y, vector.x);
        return normal.normalize();
    }

    fn Vector generate_random_point_on_radius(float radius):static
    {
        Vector result(random_float() * 2 - 1, random_float() * 2 - 1);
        result.normalize();
        result *= radius;
        return result;
    }
    fn Vector generate_random_point_in_radius(float radius):static
    {
        Vector result(random_float() * 2 - 1, random_float() * 2 - 1);
        result.normalize();
        result *= random_float() * radius;
        return result;
    }

    fn list<Vector> get_points_on_radius(float radius, int count):static
    {
        std::vector<Vector> points;

        float pi = std::acos(-1.0f);
        float step = 2.0f * pi / static_cast<float>(count);
        for (int i=0; i<count; ++i)
        {
            float angle = step * static_cast<float>(i);
            float px    = std::cos(angle) * radius;
            float py    = std::sin(angle) * radius;
            points.push_back(Vector(px, py));
        }

        return points;
    }

    fn float get_angle(Vector:const:ref direction):static
    {
        float rad = std::atan2(direction.y, direction.x);
        if (rad < 0.0f)
            rad += M_PI * 2;
        return rad;
    }

    fn Vector build_vector(float radian):static
    {
        return Vector(std::cos(radian), std::sin(radian));
    }

    fn float get_angle_between(Vector:const:ref a, Vector:const:ref b):static
    {
        float dot = a.x * b.x + a.y * b.y;
        float len_prod = a.length() * b.length();
        if (len_prod < FLOAT_SMALL)
        {
            return 0.0f;
        }

        // косинус угла
        float cosVal = dot / len_prod;
        // подстраховка: ограничиваем в [-1;1], чтобы избежать NaN из-за погрешностей
        if (cosVal >  1.0f) cosVal =  1.0f;
        if (cosVal < -1.0f) cosVal = -1.0f;

        // acos возвращает угол в радианах
        float rad = std::acos(cosVal);
        return rad;
    }
    fn float get_signed_angle_between(Vector:const:ref a, Vector:const:ref b):static
    {
        if (a.length() < FLOAT_SMALL || b.length() < FLOAT_SMALL)
        {
            return 0.0f;
        }

        float cross = a.x * b.y - a.y * b.x;
        float dot   = a.x * b.x + a.y * b.y;

        float rad = std::atan2(cross, dot);
        return rad;
    }
}