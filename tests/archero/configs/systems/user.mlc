class model/Model
{
    bool initialized = false
    int:runtime timestamp

    bool:runtime ready_to_write = false
    int:server:runtime time_on_read = 0
    
    function void initialize(int current_time):virtual
    {
        this->initialized = true;
        this->timestamp = current_time;
    }
    
    function bool is_outdate(int current_time)
    {
        return current_time - this->timestamp > 300;
    }
}

class model/ModelUserBase<Model>
{
    int id = 0
    string:private auth_key //deprecated. moved to ModelBase (on client)
    string auth_key_for_tests

    map<string, System*>:protected systems

    function<T> T* system()
    {
        for(auto&& [type, system] : this->systems)
        {
            if(type == T::TYPE)
            {
                auto result = dynamic_pointer_cast_intrusive<T>(system);
                // assert(result != nullptr);
                return result;
            }
        }
        return nullptr;
    }
    function<T> T*:const system():const:cpp
    {
        for(auto&& [type, system] : this->systems)
        {
            if(type == T::TYPE)
            {
                auto result = dynamic_pointer_cast_intrusive<T>(system);
                assert(result != nullptr);
                return result;
            }
        }
        return nullptr;
    }

    function void copy_system(System* system)
    {
        this->systems[system->get_type()] = system;
    }

    fn string get_auth_key():const
    {
        return this->auth_key;
    }
}

class model/System
{
    function void initialize(ModelUser* user):abstract;
}

class model/ModelUser<ModelUserBase>
{
    ModelUser*:static instance = nullptr
    int:server last_update_time = 0

    int:runtime session_time_start = 0
    bool accepted_policy = false

    list<string> complete_tutorial

    UserProfile* profile

    fn void update()
    {
    }

    fn ModelUser* get_instance():static:client
    {
        assert(nullptr);
        return nullptr;
    }

    function void initialize(int current_time)
    {
        ModelUserBase::initialize(current_time);
        this->upgrade(current_time);
    }

    function void upgrade(int current_time)
    {
        map_remove_if(this->systems, (type, system :> system == nullptr));
        this->session_time_start = current_time;
        if(!this->profile)
        {
            this->profile = new UserProfile();
        }

        auto params = DataStorage::shared().get<DataParams>(DataParams::DEFAULT);
        for(auto& system : params->user_systems)
        {
            auto type = system->get_type();
            if(!in_map(type, this->systems))
            {
                this->systems[type] = Factory::shared().build<System>(type);
            }
        }

        for(auto&& [type, system] : this->systems)
        {
            system->initialize(this);
        }
    }
    function bool is_payer():const
    {
        return false;
        // return map_size(this->system<SystemShop>()->purchased_products) > 0;
    }

    function void update_profile(UserProfile* profile):const:cpp
    {
        // assert(profile != nullptr);

        // auto systemHeroes = this->system<mg::SystemHeroes>();
        // auto systemTraining = this->system<mg::SystemTraining>();
        // auto squad = systemHeroes->get_squad(mg::GameMode::arena);
        // profile->heroes.clear();
        // profile->squad_power = 0;
        // for(auto unit : squad->heroes)
        // {
        //     if(!unit)
        //     {
        //         continue;
        //     }
        //     auto name = unit->name;
        //     profile->heroes[name] = mg::UserProfileHeroInfo();
        //     profile->heroes[name].data = unit;
        //     profile->heroes[name].level = systemTraining->get_unit_level(unit);
        //     profile->heroes[name].rank = systemTraining->get_rank(unit);
        //     profile->squad_power += systemTraining->get_unit_power(const_cast<ModelUser*>(this), unit);
        // }
    }
}

class model/UserProfile<Model>
{
    string name = "Player"
    bool is_base_name = true

    int id = 0
}