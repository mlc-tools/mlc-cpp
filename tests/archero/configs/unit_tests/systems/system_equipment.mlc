class tests/TestModelEquipment<ITestModelEquipment>
{
    fn void test_get_base_value_from_stats()
    {
        auto lvl1 = new DataMergeLevel(); lvl1->name = "normal"; lvl1->index = 1;
        auto lvl3 = new DataMergeLevel(); lvl3->name = "rare"; lvl3->index = 3; lvl1->next = nullptr; // not used here

        auto data = new DataEquipment();
        data->main_stat = UnitStat::damage;
        data->slot = EquipmentSlot::weapon;
        data->stats[UnitStat::damage] = 10.f; // базовое значение из stats

        auto model = new ModelEquipment();
        model->data = data;
        model->merge_level = lvl3; // индекс 3 => множитель 1 + 0.2*(3-1) = 1.4

        assertEqual(model->get_base_value(UnitStat::damage), 14.f, "main_stat масштабируется по merge_level");
        assertEqual(model->get_base_value(UnitStat::speed), 0.f, "неизвестный стат без merge_stats = 0");
    }

    fn void test_get_base_value_from_merge_level1()
    {
        auto lvl1 = new DataMergeLevel(); lvl1->name = "normal"; lvl1->index = 1;
        auto lvl3 = new DataMergeLevel(); lvl3->name = "rare"; lvl3->index = 3; lvl1->next = lvl3;

        auto data = new DataEquipment();
        data->main_stat = UnitStat::damage;
        data->slot = EquipmentSlot::weapon;

        DataEquipmentStat s1;
        s1.merge_level = lvl1;
        s1.stat = UnitStat::damage;
        s1.modifier.type = ModifierType::add;
        s1.modifier.value = 50.f;
        list_push(data->merge_stats, s1);

        auto model = new ModelEquipment();
        model->data = data;
        model->merge_level = lvl3; // индекс 3 => множитель 1.4 применяется к базе уровня 1

        // база берётся из merge_stats уровня 1 (=50), затем множитель по main_stat: 50 * 1.4 = 70
        assertEqual(model->get_base_value(UnitStat::damage), 70.f, "база из merge(1) * main_stat scale");
    }
}

class tests/TestModelEquipmentSlot<ITestModelEquipmentSlot>
{
    fn void test_get_stat_with_upgrades_and_modifiers()
    {
        auto lvl1 = new DataMergeLevel(); lvl1->name = "normal"; lvl1->index = 1;
        auto lvl3 = new DataMergeLevel(); lvl3->name = "rare"; lvl3->index = 3; lvl1->next = lvl3;

        auto data = new DataEquipment();
        data->main_stat = UnitStat::damage;
        data->slot = EquipmentSlot::weapon;
        data->stats[UnitStat::damage] = 10.f; // базовое значение

        // модификаторы на уровнях 1 и 3
        {
            DataEquipmentStat s;
            s.merge_level = lvl1; s.stat = UnitStat::damage; s.modifier.type = ModifierType::mul; s.modifier.value = 1.5f;
            list_push(data->merge_stats, s);
        }
        {
            DataEquipmentStat s;
            s.merge_level = lvl3; s.stat = UnitStat::damage; s.modifier.type = ModifierType::mul; s.modifier.value = 2.0f;
            list_push(data->merge_stats, s);
        }

        auto item = new ModelEquipment(); item->data = data; item->merge_level = lvl3; // видим оба уровневых модификатора

        ModelEquipmentSlot slot; slot.slot = EquipmentSlot::weapon; slot.item = item; slot.upgrade_level = 1; // +20% к главному стату в конце

        // база 10; get_base_value учитывает main_stat (lvl3 => *1.4) => 14; затем *1.5 *2.0 = 42; апгрейд +20% => 50.4
        assertEqual(slot.get_stat(UnitStat::damage, 0.f), 50.4f, "модификаторы и апгрейд применены");

        // если передать ненулевую базу, базовая часть не пересчитывается через get_base_value
        assertEqual(slot.get_stat(UnitStat::damage, 5.f), 5.f * 1.5f * 2.0f * 1.2f, "используется переданная база + модификаторы + апгрейд");
    }

    fn void test_get_stat_string_and_components()
    {
        auto lvl1 = new DataMergeLevel(); lvl1->name = "normal"; lvl1->index = 1;
        auto lvl2 = new DataMergeLevel(); lvl2->name = "fine"; lvl2->index = 2; lvl1->next = lvl2;
        auto lvl3 = new DataMergeLevel(); lvl3->name = "rare"; lvl3->index = 3; lvl2->next = lvl3;

        auto data = new DataEquipment(); data->slot = EquipmentSlot::weapon; data->main_stat = UnitStat::damage;
        // строковые значения для стата bullet; последнее по уровню — на lvl3
        {
            DataEquipmentStat s; s.merge_level = lvl1; s.stat = UnitStat::bullet; s.modifier.string_value = "bullet_basic"; list_push(data->merge_stats, s);
        }
        // компоненты на уровнях 1 и 3
        {
            DataEquipmentStat s; s.merge_level = lvl1; s.stat = UnitStat::damage; s.component = new ComponentShootBullet(); list_push(data->merge_stats, s);
        }
        {
            DataEquipmentStat s; s.merge_level = lvl3; s.stat = UnitStat::bullet; s.modifier.string_value = "bullet_shotgun"; list_push(data->merge_stats, s);
        }
        {
            DataEquipmentStat s; s.merge_level = lvl3; s.stat = UnitStat::damage; s.component = new ComponentShootBullet(); list_push(data->merge_stats, s);
        }

        auto item = new ModelEquipment(); item->data = data; item->merge_level = lvl2; // индекс 2 — виден только уровень 1
        ModelEquipmentSlot slot; slot.slot = EquipmentSlot::weapon; slot.item = item;

        assertEqual(slot.get_stat_string(UnitStat::bullet), std::string("bullet_basic"), "строка с уровня 1 при merge=2");
        auto comps_lvl2 = slot.get_ecs_components();
        assertEqual(list_size(comps_lvl2), 1, "1 компонент до lvl2");

        item->merge_level = lvl3;
        assertEqual(slot.get_stat_string(UnitStat::bullet), std::string("bullet_shotgun"), "строка с уровня 3 при merge=3");
        auto comps_lvl3 = slot.get_ecs_components();
        assertEqual(list_size(comps_lvl3), 2, "2 компонента до lvl3");
    }
}

class tests/TestSystemEquipment<ITestSystemEquipment>
{
    @include ModelEquipmentSlot
    fn void test_initialize_slot_and_add_item()
    {
        auto normal = new DataMergeLevel(); normal->name = "normal"; normal->index = 1;

        SystemEquipment sys;
        sys.initialize_slot(EquipmentSlot::weapon);
        assertEqual(map_size(sys.slots), 1, "слот инициализирован");
        assertEqual(sys.slots[EquipmentSlot::weapon]->slot, EquipmentSlot::weapon, "слот проставлен");
        assertEqual(sys.slots[EquipmentSlot::weapon]->item == nullptr, true, "предмет не экипирован");

        auto data = new DataEquipment(); data->slot = EquipmentSlot::ring; data->main_stat = UnitStat::damage;
        auto item = sys.add_item(data, normal);
        assertEqual(list_size(sys.items), 1, "предмет добавлен в инвентарь");
        assertEqual(item->data == data, true, "ссылка на data сохранена");
        assertEqual(item->merge_level == normal, true, "уровень слияния проставлен");
    }

    fn void test_equip_and_unequip()
    {
        auto normal = new DataMergeLevel(); normal->name = "normal"; normal->index = 1;

        SystemEquipment sys; sys.initialize_slot(EquipmentSlot::weapon);

        auto d1 = new DataEquipment(); d1->slot = EquipmentSlot::weapon; d1->main_stat = UnitStat::damage;
        auto d2 = new DataEquipment(); d2->slot = EquipmentSlot::weapon; d2->main_stat = UnitStat::damage;
        auto i1 = sys.add_item(d1, normal);
        auto i2 = sys.add_item(d2, normal);

        sys.equip(i1);
        assertEqual(sys.slots[EquipmentSlot::weapon]->item == i1, true, "экипирован первый");
        assertEqual(i1->equip, true, "флаг equip для первого");

        sys.equip(i2);
        assertEqual(sys.slots[EquipmentSlot::weapon]->item == i2, true, "переэкипирован на второй");
        assertEqual(i1->equip, false, "первый снят");
        assertEqual(i2->equip, true, "второй экипирован");

        sys.unequip(i2);
        assertEqual(sys.slots[EquipmentSlot::weapon]->item == nullptr, true, "слот очищен");
        assertEqual(i2->equip, false, "второй снят");
    }

    fn void test_get_stat_and_string()
    {
        // два предмета в разных слотах модифицируют один и тот же стат
        auto lvl1 = new DataMergeLevel(); lvl1->name = "normal"; lvl1->index = 1;
        auto lvl3 = new DataMergeLevel(); lvl3->name = "rare"; lvl3->index = 3; lvl1->next = lvl3;

        // weapon: base=10, mul1.5 (lvl1)
        auto dw = new DataEquipment(); dw->slot = EquipmentSlot::weapon; dw->main_stat = UnitStat::damage; dw->stats[UnitStat::damage] = 10.f;
        { DataEquipmentStat s; s.merge_level = lvl1; s.stat = UnitStat::damage; s.modifier.type = ModifierType::mul; s.modifier.value = 1.5f; list_push(dw->merge_stats, s); }
        { DataEquipmentStat s; s.merge_level = lvl1; s.stat = UnitStat::bullet; s.modifier.string_value = "bullet_basic"; list_push(dw->merge_stats, s); }

        // ring: mul2.0 (lvl3), string override to "bullet_shotgun" on lvl3
        auto dr = new DataEquipment(); dr->slot = EquipmentSlot::ring; dr->main_stat = UnitStat::damage;
        { DataEquipmentStat s; s.merge_level = lvl3; s.stat = UnitStat::damage; s.modifier.type = ModifierType::mul; s.modifier.value = 2.0f; list_push(dr->merge_stats, s); }
        { DataEquipmentStat s; s.merge_level = lvl3; s.stat = UnitStat::bullet; s.modifier.string_value = "bullet_shotgun"; list_push(dr->merge_stats, s); }

        auto iw = new ModelEquipment(); iw->data = dw; iw->merge_level = lvl1;
        auto ir = new ModelEquipment(); ir->data = dr; ir->merge_level = lvl3;

        SystemEquipment sys; sys.initialize_slot(EquipmentSlot::weapon); sys.initialize_slot(EquipmentSlot::ring);
        sys.equip(iw);
        sys.equip(ir);

        // агрегирование: сначала weapon: base=10 -> *1.5 = 15; затем ring (*2.0) => 30
        assertEqual(sys.get_stat(UnitStat::damage, 0.f), 30.f, "агрегированный стат из двух слотов");
        assertEqual(sys.get_stat_string(UnitStat::bullet), std::string("bullet_shotgun"), "последняя непустая строка из слотов");
    }

    fn void test_get_items_with_merge_level_and_request_merge()
    {
        auto normal = new DataMergeLevel(); normal->name = "normal"; normal->index = 1;
        auto fine = new DataMergeLevel(); fine->name = "fine"; fine->index = 2; normal->next = fine;

        SystemEquipment sys;
        auto d = new DataEquipment(); d->slot = EquipmentSlot::amulet; d->main_stat = UnitStat::speed;
        auto a = sys.add_item(d, normal);
        auto b = sys.add_item(d, normal);
        auto c = sys.add_item(d, fine);

        auto normals = sys.get_items_with_merge_level(normal);
        assertEqual(list_size(normals), 2, "фильтрация по уровню слияния");

        list<intrusive_ptr<ModelEquipment>> merging;
        list_push(merging, b);
        list_push(merging, c); // c не из normal, но метод просто удаляет переданные элементы из списка

        sys.request_merge(a, merging);
        assertEqual(a->merge_level == fine, true, "уровень целевого увеличен");
        assertEqual(list_size(sys.items), 1, "элементы для слияния удалены");
    }
}
