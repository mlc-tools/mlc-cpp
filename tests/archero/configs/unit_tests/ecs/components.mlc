class tests/TestComponentData<ITestComponentData>
{
    fn void test_constructor()
    {
        DataUnit unit;
        ComponentData comp(&unit);
        assertTrue(comp.data == &unit, "stores unit link");
    }
}

class tests/TestTransform<ITestTransform>
{
    fn void test_set()
    {
        Transform t;
        Vector a(1,2);
        t.set(a);
        assertEqual(t.position.x, 1.f, "pos x");
        assertEqual(t.position.y, 2.f, "pos y");
        assertEqual(t.prev_position.x, 0.f, "prev x");
        assertEqual(t.prev_position.y, 0.f, "prev y");
        Vector b(3,4);
        t.set(b);
        assertEqual(t.prev_position.x, 1.f, "prev x after second set");
        assertEqual(t.prev_position.y, 2.f, "prev y after second set");
    }
}

class tests/TestComponentStats<ITestComponentStats>
{
    fn void test_get()
    {
        DataUnit unit;
        unit.stats[UnitStat::damage] = 10.f;
        ComponentStats stats;
        stats.data = &unit;
        auto model = new ModelEcsBaseMock();
        assertEqual(stats.get(model, UnitStat::damage), 10.f, "base stat");
    }

    fn void test_add_upgrade()
    {
        DataUnit unit;
        unit.stats[UnitStat::damage] = 10.f;
        ComponentStats stats;
        stats.data = &unit;
        DataStatUpgrade up;
        up.name = "up";
        up.stats.push_back(UnitStat::damage);
        Modifier mod;
        mod.type = ModifierType::add;
        mod.value = 5.f;
        up.modifiers.push_back(mod);
        stats.add_upgrade(&up);
        auto model = new ModelEcsBaseMock();
        assertEqual(stats.get(model, UnitStat::damage), 15.f, "upgrade applied");
    }

    fn void test_set_fixed()
    {
        DataUnit unit;
        unit.stats[UnitStat::damage] = 10.f;
        ComponentStats stats;
        stats.data = &unit;
        auto model = new ModelEcsBaseMock();
        stats.set_fixed(UnitStat::damage, 20.f);
        assertEqual(stats.get(model, UnitStat::damage), 20.f, "fixed value");
    }

    fn void test_reset_cashe()
    {
        DataUnit unit;
        unit.stats[UnitStat::damage] = 10.f;
        ComponentStats stats;
        stats.data = &unit;
        auto model = new ModelEcsBaseMock();
        stats.set_fixed(UnitStat::damage, 20.f);
        stats.reset_cashe(UnitStat::damage);
        assertEqual(stats.get(model, UnitStat::damage), 10.f, "cache reset");
    }

    fn void test_remove_upgrade()
    {
        DataUnit unit;
        unit.stats[UnitStat::damage] = 10.f;
        ComponentStats stats;
        stats.data = &unit;
        DataStatUpgrade up;
        up.name = "u";
        up.stats.push_back(UnitStat::damage);
        Modifier mod;
        mod.type = ModifierType::add;
        mod.value = 5.f;
        up.modifiers.push_back(mod);
        stats.add_upgrade(&up);
        auto model = new ModelEcsBaseMock();
        assertEqual(stats.get(model, UnitStat::damage), 15.f, "upgraded");
        stats.remove_upgrade(&up);
        stats.reset_cashe(UnitStat::damage);
        assertEqual(stats.get(model, UnitStat::damage), 10.f, "removed upgrade");
    }

    fn void test_get_stat_base()
    {
        DataUnit unit;
        unit.stats[UnitStat::damage] = 7.f;
        ComponentStats stats;
        stats.data = &unit;
        assertEqual(stats.get_stat_base(UnitStat::damage), 7.f, "base value");
        assertEqual(stats.get_stat_base(UnitStat::speed), 0.f, "missing stat");
    }

    fn void test_get_string()
    {
        DataUnit unit;
        unit.stats_string[UnitStat::bullet] = "arrow";
        ComponentStats stats;
        stats.data = &unit;
        auto model = new ModelEcsBaseMock();
        assertEqual(stats.get_string(model, UnitStat::bullet), "arrow", "string stat");
    }
}

class tests/TestComponentSide<ITestComponentSide>
{
    fn void test_is_enemy()
    {
        ComponentSide c;
        c.side = Side::ally;
        assertTrue(c.is_enemy(Side::enemy), "ally vs enemy");
        assertFalse(c.is_enemy(Side::ally), "ally vs ally");
        c.side = Side::enemy;
        assertTrue(c.is_enemy(Side::ally), "enemy vs ally");
        c.side = Side::neutral;
        assertFalse(c.is_enemy(Side::ally), "neutral");
    }
}

class tests/TestComponentTargetable<ITestComponentTargetable>
{
    fn void test_construct()
    {
        ComponentTargetable t;
        assertNotNull(&t, "constructed");
    }
}

class tests/TestComponentHealth<ITestComponentHealth>
{
    fn void test_get_current()
    {
        ComponentHealth h;
        assertEqual(h.get_current(), 0.f, "default current");
    }

    fn void test_set_current()
    {
        ComponentHealth h;
        h.set_current(100.f);
        assertEqual(h.get_current(), 100.f, "current set");
    }

    fn void test_get_future_damage()
    {
        ComponentHealth h;
        assertEqual(h.get_future_damage(1), 0.f, "no future damage");
    }

    fn void test_add_future_damage()
    {
        ComponentHealth h;
        h.add_future_damage(1, 10.f);
        assertEqual(h.get_future_damage(1), 10.f, "future damage added");
    }

    fn void test_remove_future_damage()
    {
        ComponentHealth h;
        h.add_future_damage(1, 10.f);
        h.remove_future_damage(1);
        assertEqual(h.get_future_damage(1), 0.f, "future damage removed");
    }

    fn void test_get_future_value()
    {
        ComponentHealth h;
        h.set_current(100.f);
        h.add_future_damage(1, 20.f);
        assertEqual(h.get_future_value(), 80.f, "future value");
    }

    fn void test_damage()
    {
        ComponentHealth h;
        h.set_current(50.f);
        h.add_future_damage(1, 10.f);
        h.damage(1, 20.f);
        assertEqual(h.get_current(), 30.f, "damage applied");
        assertEqual(h.get_future_damage(1), 0.f, "future removed");
        assertEqual(h.get_future_value(), 30.f, "future value updated");
    }
}

class tests/TestComponentDamage<ITestComponentDamage>
{
    fn void test_fields()
    {
        ComponentDamage d;
        d.attacker_id = 1;
        d.bullet_id = 2;
        d.target_id = 3;
        d.damage = 4.f;
        assertEqual(d.attacker_id, 1, "attacker");
        assertEqual(d.bullet_id, 2, "bullet");
        assertEqual(d.target_id, 3, "target");
        assertEqual(d.damage, 4.f, "damage");
    }
}

class tests/TestComponentUser<ITestComponentUser>
{
    fn void test_user_field()
    {
        ComponentUser c;
        auto user = new ModelUser();
        c.user = user;
        assertEqual(c.user, user, "user pointer");
    }
}

class tests/SpineInfoStub<ComponentSpineInfo>
{
    fn float get_animation_duration(string animation)
    {
        return 1.f;
    }
    fn Vector get_bone_position(string bone)
    {
        return Vector(1.f,2.f);
    }
    fn float get_event_time(string animation, string event)
    {
        return 0.5f;
    }
    fn float get_direction()
    {
        return 2.f;
    }
}

class tests/TestComponentSpineInfo<ITestComponentSpineInfo>
{
    fn void test_get_animation_duration()
    {
        SpineInfoStub s;
        assertEqual(s.get_animation_duration("run"), 1.f, "duration");
    }

    fn void test_get_bone_position()
    {
        SpineInfoStub s;
        auto pos = s.get_bone_position("head");
        assertEqual(pos.x, 1.f, "pos x");
        assertEqual(pos.y, 2.f, "pos y");
    }

    fn void test_get_event_time()
    {
        SpineInfoStub s;
        assertEqual(s.get_event_time("anim","evt"), 0.5f, "event time");
    }

    fn void test_get_direction()
    {
        SpineInfoStub s;
        assertEqual(s.get_direction(), 2.f, "direction");
    }
}

class tests/TestComponentBusy<ITestComponentBusy>
{
    fn void test_default()
    {
        ComponentBusy b;
        assertFalse(b.is_busy, "default not busy");
        b.is_busy = true;
        assertTrue(b.is_busy, "set busy");
    }
}
