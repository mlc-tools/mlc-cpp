
class tests/GroundStub
{
    fn bool has_collision_with_walls(Vector:const:ref pos, float radius):const
    {
        return false;
    }
}

class tests/DataWaveDummy<DataWaveBase>
{
    fn list<SpawnInfo> get_units(ModelEcsBase* model):const
    {
        return {};
    }
}

class tests/TestDataLevel<ITestDataLevel>
{
    fn void test_is_change_view_on_next_wave()
    {
        DataLevel level;
        assertFalse(level.is_change_view_on_next_wave(), "no maps");
        level.tmx_maps.push_back("map");
        assertTrue(level.is_change_view_on_next_wave(), "has maps");
    }
}

class tests/TestSpawnInfo<ITestSpawnInfo>
{
    @include SpawnInfo
    fn void test_constructor()
    {
        DataUnit unit;
        Vector pos(1, 2);
        SpawnInfo info(pos, &unit);
        assertEqual(info.position.x, 1.f, "x");
        assertEqual(info.position.y, 2.f, "y");
        assertEqual(info.unit, &unit, "unit ptr");
    }
}

class tests/TestDataWaveBase<ITestDataWaveBase>
{
    @include SpawnInfo
    fn void test_get_units()
    {
        DataWaveDummy wave;
        auto res = wave.get_units(nullptr);
        assertEqual(res.size(), 0, "dummy empty");
    }
}

class tests/TestDataWaveOnSpawnPoints<ITestDataWaveOnSpawnPoints>
{
    @include SpawnInfo
    fn void test_get_units()
    {
        auto model = new ModelEcsBaseMock();
        model->spawn_points["p"] = Vector(1, 2);
        DataWaveOnSpawnPoints wave;
        DataUnit unit;
        wave.units["p"] = &unit;
        auto res = wave.get_units(model);
        assertEqual(res.size(), 1, "one spawn");
        assertEqual(res[0].position.x, 1.f, "x");
        assertEqual(res[0].position.y, 2.f, "y");
        assertEqual(res[0].unit, &unit, "unit");
    }
}

class tests/TestDataWaveOnSpawnPointsRandom<ITestDataWaveOnSpawnPointsRandom>
{
    @include SpawnInfo
    fn void test_get_points()
    {
        auto model = new ModelEcsBaseMock();
        map_clear(model->spawn_points);

        model->spawn_points["near"] = Vector(1, 1);
        model->spawn_points["far"] = Vector(100, 100);
        DataWaveOnSpawnPointsRandom wave;
        wave.min_distance_to_player = 5.f;
        auto points = wave.get_points(model);
        assertEqual(points.size(), 1, "only near point");
        assertTrue(fabs(points[0].x - 1.f) < 0.1f, "px");
        assertTrue(fabs(points[0].y - 1.f) < 0.1f, "py");
    }
    fn void test_get_units()
    {
        auto model = new ModelEcsBaseMock();
        map_clear(model->spawn_points);

        model->spawn_points["near"] = Vector(1, 1);
        DataWaveOnSpawnPointsRandom wave;
        wave.min_distance_to_player = 5.f;
        wave.units.push_back(nullptr);
        auto res = wave.get_units(model);
        assertEqual(res.size(), 1, "spawn count");
        assertTrue(fabs(res[0].position.x - 1.f) < 0.1f, "x");
        assertTrue(fabs(res[0].position.y - 1.f) < 0.1f, "y");
    }
}

class tests/TestDataWaveOnRadius<ITestDataWaveOnRadius>
{
    @include SpawnInfo
    fn void test_get_units()
    {
        auto model = new ModelEcsBaseMock();


        model->get<Transform>(model->player_id)->position = Vector(0, 0);
        DataWaveOnRadius wave;
        wave.min_distance_to_player = 1.f;
        wave.max_distance_to_player = 2.f;
        DataUnit unit;
        unit.stats[UnitStat::size] = 1.f;
        wave.units.push_back(&unit);
        auto res = wave.get_units(model);
        assertEqual(res.size(), 1, "spawn count");
        float dist = res[0].position.length();
        assertInRange(dist, 1.f, 2.f, "within radius");
        assertEqual(res[0].unit, &unit, "unit");
    }
}
