class tests/ModelEcsBaseMock<ModelEcsBase>
{
    @include BuilderEntity
    constructor(bool create_hero=true)
    {
        this->ground = new Ground();

        if(create_hero)
        {
            auto data = DataStorage::shared().get<DataUnit>("hero_survival");
            this->spawn_points["hero"] = Vector(0, 0);
            auto pos = this->spawn_points.at("hero");
            this->player_id = BuilderEntity(data).set_position(pos).set_side(Side::ally).build(this);
        }
    }
}

class tests/TestModelEcsBase<ITestModelEcsBase>
{
    fn void test_get_free_id()
    {
        auto model = new ModelEcsBaseMock(false);
        assertEqual(model->get_free_id(), 1, "first id");
        assertEqual(model->get_free_id(), 2, "second id");
    }

    fn void test_add_entity()
    {
        auto model = new ModelEcsBaseMock();
        model->add_entity(5);
        assertInList(5, model->entities, "added");
    }

    fn void test_remove_entity()
    {
        auto model = new ModelEcsBaseMock();
        model->add_entity(5);
        model->remove_entity(5);
        assertNotInList(5, model->entities, "removed");
    }

    fn void test_update()
    {
        auto model = new ModelEcsBaseMock();
        model->update(0.5f);
        assertEqual(model->game_timer, 0.5f, "timer");
    }

    fn void test_get_entity_with_name()
    {
        auto model = new ModelEcsBaseMock();
        assertEqual(model->get_entity_with_name("hero"), 0, "default none");
    }

    fn void test_get_health_rate()
    {
        auto model = new ModelEcsBaseMock();
        assertEqual(model->get_health_rate(), 1.f, "health rate");
    }

    fn void test_update_systems()
    {
        auto model = new ModelEcsBaseMock();
        model->update_systems(0.1f);
        assertTrue(true, "called");
    }

    fn void test_subscribe()
    {
        auto model = new ModelEcsBaseMock();
        model->subscribe();
        assertTrue(true, "subscribed");
    }

    fn void test_unsubscribe()
    {
        auto model = new ModelEcsBaseMock();
        model->unsubscribe();
        assertTrue(true, "unsubscribed");
    }

    fn void test_on_loaded()
    {
        auto model = new ModelEcsBaseMock();
        model->on_loaded();
        assertTrue(true, "loaded");
    }
}

class tests/TestTask<ITestTask>
{
    fn void test_construct()
    {
        Task t;
        assertNotNull(&t, "constructed");
    }
}

class tests/TestCell<ITestCell>
{
    fn void test_constructor()
    {
        Cell cell(1,2);
        assertEqual(cell.row, 1, "row");
        assertEqual(cell.col, 2, "col");
    }
}

class tests/TestGround<ITestGround>
{
    fn void test_get_width_tiles()
    {
        Ground g;
        g.ground = {{0,0},{0,0}};
        assertEqual(g.get_width_tiles(), 2, "width");
    }

    fn void test_get_height_tiles()
    {
        Ground g;
        g.ground = {{0,0},{0,0}};
        assertEqual(g.get_height_tiles(), 2, "height");
    }

    fn void test_get_center_position()
    {
        Ground g;
        g.ground = {{0,0},{0,0}};
        auto center = g.get_center_position();
        assertEqual(center.x, 64.f, "center x");
        assertEqual(center.y, 64.f, "center y");
    }

    fn void test_convert_position_to_tile()
    {
        Ground g;
        g.ground = {{0,0},{0,0}};
        auto c = g.convert_position_to_tile(Vector(32.f,32.f));
        assertEqual(c.row, 0, "pos to tile row");
        assertEqual(c.col, 0, "pos to tile col");
    }

    fn void test_conver_tile_to_position()
    {
        Ground g;
        g.ground = {{0,0},{0,0}};
        Cell cell;
        cell.row = 1;
        cell.col = 1;
        auto pos = g.conver_tile_to_position(cell);
        assertEqual(pos.x, 64.f, "tile to pos x");
        assertEqual(pos.y, 64.f, "tile to pos y");
    }

    fn void test_is_bound()
    {
        Ground g;
        g.ground = {{0,0},{0,0}};
        assertTrue(g.is_bound(Vector(10.f,10.f)), "inside");
        assertFalse(g.is_bound(Vector(-1.f,10.f)), "outside");
    }

    fn void test_has_collision_with_walls()
    {
        Ground g;
        g.ground = {{0,1},{0,0}};
        assertFalse(g.has_collision_with_walls(Vector(10.f,10.f), 1.f), "no collision");
        assertTrue(g.has_collision_with_walls(Vector(96.f,10.f), 1.f), "wall collision");
    }
}
