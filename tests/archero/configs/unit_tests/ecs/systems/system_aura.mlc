class tests/TestSystemAuroOfSlow<ITestSystemAuroOfSlow>
{
    fn void test_update()
    {
        // Базовая проверка — цель в радиусе получает замедление
        auto model = new ModelEcsBaseMock(false);
        model->ground->ground = {{0,0},{0,0}};
        DataUnit aura_unit;
        int aura_id = BuilderEntity(&aura_unit).set_side(Side::ally).set_position(Vector(0,0)).build(model);
        auto aura = new ComponentAuraOfSlow();
        aura->radius = 10.f;
        model->add(aura, aura_id);
        DataUnit unit;
        int id = BuilderEntity(&unit).set_side(Side::enemy).set_position(Vector(5,0)).build(model);
        model->add(new ComponentMovement(), id);
        SystemAuroOfSlow().update(model, 0.0f);
        auto mv = model->get<ComponentMovement>(id);
        assertNotNull(mv->aura_slow, "замедление активно");
    }
    fn void test_update_inside()
    {
        auto model = new ModelEcsBaseMock(false);
        model->ground->ground = {{0,0},{0,0}};

        // Создаем сущность-ауру
        DataUnit aura_unit;
        int aura_id = BuilderEntity(&aura_unit).set_side(Side::ally).set_position(Vector(32,32)).build(model);
        auto aura = new ComponentAuraOfSlow();
        aura->radius = 20.f;
        model->add(aura, aura_id);

        // Создаем сущность-цель с движением внутри радиуса
        DataUnit unit;
        int id = BuilderEntity(&unit).set_side(Side::enemy).set_position(Vector(40,32)).build(model);
        auto movement = new ComponentMovement();
        model->add(movement, id);

        SystemAuroOfSlow sys;
        sys.update(model, 0.0f);

        auto mv = model->get<ComponentMovement>(id);
        assertNotNull(mv->aura_slow, "получена аура замедления");
        assertInRange(mv->slow_k, 0.5f, 1.0f, "коэффициент замедления в диапазоне");
    }

    fn void test_update_outside()
    {
        auto model = new ModelEcsBaseMock(false);
        model->ground->ground = {{0,0},{0,0}};

        // Аура в центре
        DataUnit aura_unit;
        int aura_id = BuilderEntity(&aura_unit).set_side(Side::ally).set_position(Vector(32,32)).build(model);
        auto aura = new ComponentAuraOfSlow();
        aura->radius = 10.f;
        model->add(aura, aura_id);

        // Цель далеко от радиуса
        DataUnit unit;
        int id = BuilderEntity(&unit).set_side(Side::enemy).set_position(Vector(200,200)).build(model);
        auto movement = new ComponentMovement();
        model->add(movement, id);

        SystemAuroOfSlow sys;
        sys.update(model, 0.0f);

        auto mv = model->get<ComponentMovement>(id);
        assertNull(mv->aura_slow, "аура не применяется вне радиуса");
        assertEqual(mv->slow_k, 1.f, "без замедления вне радиуса");
    }
}

class tests/TestSystemAuraDamage<ITestSystemAuraDamage>
{
    fn void test_update()
    {
        auto model = new ModelEcsBaseMock(false);
        model->ground->ground = {{0,0},{0,0}};
        DataUnit aura_du; aura_du.stats[UnitStat::damage] = 5.f;
        int aura_id = BuilderEntity(&aura_du).set_side(Side::ally).set_position(Vector(0,0)).build(model);
        auto aura = new ComponentAuraDamage();
        aura->radius = 10.f;
        model->add(aura, aura_id);
        DataUnit victim_du; victim_du.stats[UnitStat::health] = 50.f;
        int victim_id = BuilderEntity(&victim_du).set_side(Side::enemy).set_position(Vector(5,0)).build(model);
        auto health = model->get<ComponentHealth>(victim_id);
        float h0 = health->get_current();
        SystemAuraDamage().update(model, 0.0f);
        SystemDamage().update(model, 0.0f);
        SystemRemoveDamage().clean(model);
        assertTrue(health->get_current() < h0, "урон применён");
    }
    fn void test_damage_and_cooldown()
    {
        auto model = new ModelEcsBaseMock(false);
        model->ground->ground = {{0,0},{0,0}};

        // Создаем ауро-носителя с уроном
        DataUnit aura_du;
        aura_du.stats[UnitStat::damage] = 10.f;
        int aura_id = BuilderEntity(&aura_du).set_side(Side::ally).set_position(Vector(32,32)).build(model);
        auto aura = new ComponentAuraDamage();
        aura->radius = 30.f;
        aura->damage_mul = 0.2f;
        model->add(aura, aura_id);

        // Жертва в радиусе
        DataUnit victim_du;
        victim_du.stats[UnitStat::health] = 100.f;
        int victim_id = BuilderEntity(&victim_du).set_side(Side::enemy).set_position(Vector(40,32)).build(model);
        auto health = model->get<ComponentHealth>(victim_id);
        health->set_current(100.f);

        SystemAuraDamage sys;
        float expected = aura_du.stats[UnitStat::damage] * aura->damage_mul;
        float h0 = health->get_current();

        // Первый тик урона
        sys.update(model, 0.0f);
        SystemDamage().update(model, 0.0f);
        SystemRemoveDamage().clean(model);
        assertInRange(health->get_current(), h0 - expected - 0.001f, h0 - expected + 0.001f, "получен урон 1й тик");

        // На перезарядке — второй тик урона не должен появиться
        sys.update(model, 0.0f);
        SystemDamage().update(model, 0.0f);
        SystemRemoveDamage().clean(model);
        assertInRange(health->get_current(), h0 - expected - 0.001f, h0 - expected + 0.001f, "на кулдауне урона нет");

        // Снимаем кулдаун и проверяем повторный урон
        sys.update(model, 1.0f); // 2 -> 1
        sys.update(model, 1.0f); // 1 -> 0
        sys.update(model, 0.0f); // теперь должен нанестись урон снова
        SystemDamage().update(model, 0.0f);
        SystemRemoveDamage().clean(model);
        assertInRange(health->get_current(), h0 - expected*2 - 0.001f, h0 - expected*2 + 0.001f, "урон повторился после кулдауна");
    }
}
