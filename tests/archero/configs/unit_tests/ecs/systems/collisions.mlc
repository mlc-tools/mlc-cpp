class tests/TestSystemResolveCollisions<ITestSystemResolveCollisions>
{
    fn void test_update()
    {
        auto model = new ModelEcsBaseMock(false);
        // простая площадка без стен
        model->ground->ground = {{0,0,0},{0,0,0}};

        DataUnit unit;
        unit.stats[UnitStat::size] = 10.f;
        int a = BuilderEntity(&unit).set_side(Side::ally).set_position(Vector(32,32)).build(model);
        int b = BuilderEntity(&unit).set_side(Side::enemy).set_position(Vector(38,32)).build(model);

        auto ta = model->get<Transform>(a);
        auto tb = model->get<Transform>(b);

        SystemResolveCollisions sys;
        sys.update(model, 0.0f);

        float size = unit.stats[UnitStat::size];
        bool overlap = (ta->position.get_distance_sq(tb->position) < (size+size)*(size+size));
        assertFalse(overlap, "системой объекты разведены");
    }

    fn void test_resole_collision_with_poly()
    {
        auto model = new ModelEcsBaseMock(false);
        // квадрат-стена (0,0)-(64,0)-(64,64)-(0,64)
        Polygon square;
        square.points = {Vector(0,0), Vector(64,0), Vector(64,64), Vector(0,64)};
        square.bbox.update(square.points);
        list_push(model->ground->wall_polygons, square);
        model->ground->ground = {{0,0},{1000,1000}};

        DataUnit unit;
        unit.stats[UnitStat::size] = 8.f;
        int id = BuilderEntity(&unit).set_side(Side::ally).set_position(Vector(60,60)).build(model);
        auto t = model->get<Transform>(id);
        auto before = t->position;

        SystemResolveCollisions sys;
        sys.resole_collision_with_poly(model);

        bool equal = fabs(t->position.x - before.x) < 0.1f;
        equal = equal && fabs(t->position.y - before.y) < 0.1f;
        assertFalse(equal, "позиция изменилась по x или y");
    }

    fn void test_notify()
    {
        // Достаточно проверить, что метод вызывается без падения,
        // когда подписчиков нет.
        SystemResolveCollisions sys;
        sys.notify(123, 456);
        assertTrue(true, "notify безопасен без подписчиков");
    }

    fn void test_is_collision()
    {
        Transform a; a.position = Vector(0,0);
        Transform b; b.position = Vector(10,0);
        SystemResolveCollisions sys;
        assertTrue(sys.is_collision(&a, &b, 8.f, 5.f), "есть пересечение");
        b.position = Vector(20,0);
        assertFalse(sys.is_collision(&a, &b, 8.f, 5.f), "нет пересечения");
    }

    fn void test_resole_collision()
    {
        auto model = new ModelEcsBaseMock(false);
        model->ground->ground = {{0,0,0},{0,0,0}};
        Transform a; a.position = Vector(0,0);
        Transform b; b.position = Vector(10,0);
        SystemResolveCollisions sys;
        sys.resole_collision(model, &a, &b, 8.f, 5.f);
        bool overlap = ((a.position.get_distance_sq(b.position)) < (8.f+5.f)*(8.f+5.f));
        assertFalse(overlap, "после resolve пересечения нет");
    }

    fn void test_can_move()
    {
        auto model = new ModelEcsBaseMock(false);
        // поле 2x2, без стен
        model->ground->ground = {{0,0},{0,0}};
        assertTrue(SystemResolveCollisions::can_move(model, 0, Vector(10,10), 1.f), "пусто — двигаться можно");
        // ставим стену в (1,0)
        model->ground->ground = {{0,1},{0,0}};
        assertFalse(SystemResolveCollisions::can_move(model, 0, Vector(96,10), 1.f), "стена — двигаться нельзя");
    }

    fn void test_is_wall()
    {
        auto model = new ModelEcsBaseMock(false);
        model->ground->ground = {{0,1},{0,0}};
        assertTrue(SystemResolveCollisions::is_wall(model, 0, Vector(96,10), 1.f), "обнаружена стена");
        assertFalse(SystemResolveCollisions::is_wall(model, 0, Vector(10,10), 1.f), "нет стены");
    }

    fn void test_find_collision_ray_and_walls()
    {
        auto model = new ModelEcsBaseMock(false);
        // квадрат-стена (0,0)-(64,0)-(64,64)-(0,64)
        Polygon square;
        square.points = {Vector(0,0), Vector(64,0), Vector(64,64), Vector(0,64)};
        square.bbox.update(square.points);
        list_push(model->ground->wall_polygons, square);
        model->ground->ground = {{0,0},{0,0}};

        Vector origin(-32, 32);
        Vector dir(1, 0);
        auto p = SystemResolveCollisions::find_collision_ray_and_walls(model, origin, dir, 0.0f);
        assertEqual(p.x, 0.f, "точка пересечения x");
        assertEqual(p.y, 32.f, "точка пересечения y");
    }

    fn void runCollisionTests()
    {
        // Квадрат (0,0)-(1,0)-(1,1)-(0,1)
        Polygon square;
        square.points = {
            Vector(0,0), Vector(1,0), Vector(1,1), Vector(0,1)
        };
        square.bbox.update(square.points);

        {
            // круг внутри квадрата
            Circle c;
            c.center = Vector(0.5f,0.5f);
            c.radius = 0.1f;
            CollisionResult res = CollisionChecker::polygon_circle_mtv(square, c);
            assertTrue(res.collision);
            assertTrue(res.penetration > 0);            
        }
        {
            // касание стороны
            Circle c;
            c.center = Vector(0.5f,-0.1f);
            c.radius = 0.1f;
            CollisionResult res = CollisionChecker::polygon_circle_mtv(square, c);
            assertTrue(res.collision);            
        }
        {
            // касание угла
            Circle c;
            c.center = Vector(1.1f,1.1f);
            c.radius = 0.2f;
            CollisionResult res = CollisionChecker::polygon_circle_mtv(square, c);
            assertTrue(res.collision);            
        }
        {
            // нет пересечения
            Circle c;
            c.center = Vector(2.0f,2.0f);
            c.radius = 0.5f;
            CollisionResult res = CollisionChecker::polygon_circle_mtv(square, c);
            assertTrue(!res.collision);            
        }
        {
            Circle c;
            c.center = Vector(1.f, 0.5f);
            c.radius = 0.5f;
            CollisionResult res = CollisionChecker::polygon_circle_mtv(square, c);
            assertTrue(res.collision);
            assertTrue(res.mtv == Vector(0.5, 0));            
        }
        {
            Circle c;
            c.center = Vector(0.f, 0.5f);
            c.radius = 0.5f;
            CollisionResult res = CollisionChecker::polygon_circle_mtv(square, c);
            assertTrue(res.collision);
            assertTrue(res.mtv == Vector(-0.5, 0));            
        }
        {
            Circle c;
            c.center = Vector(0.5f, 0);
            c.radius = 0.5f;
            CollisionResult res = CollisionChecker::polygon_circle_mtv(square, c);
            assertTrue(res.collision);
            assertTrue(res.mtv == Vector(0, -0.5));            
        }
        {
            Circle c;
            c.center = Vector(0.5f, 1);
            c.radius = 0.5f;
            CollisionResult res = CollisionChecker::polygon_circle_mtv(square, c);
            assertTrue(res.collision);
            assertTrue(res.mtv == Vector(0, 0.5));            
        }
        {
            Ray ray;
            ray.origin = Vector(-1, 0.5);
            ray.direction = Vector(1, 0);
            Vector point;
            bool res = CollisionChecker::has_collision(ray, square, point);
            assertTrue(res);
            assertTrue(point == Vector(0, 0.5));            
        }
        {
            Ray ray;
            ray.origin = Vector(-1, 1.5);
            ray.direction = Vector(1, 0);
            Vector point;
            bool res = CollisionChecker::has_collision(ray, square, point);
            assertTrue(!res);            
        }
        {
            Ray ray;
            ray.origin = Vector(0.5, 0.5);
            ray.direction = Vector(1, 0);
            Vector point;
            bool res = CollisionChecker::has_collision(ray, square, point);
            assertTrue(res);
            assertTrue(point == Vector(1, 0.5));            
        }
        {
            Segment seg;
            seg.start = Vector(-1, 0.5);
            seg.end = Vector(1, 0.5);
            Circle c;
            c.center = Vector(0, 0.5);
            c.radius = 0.3f;
            bool res = CollisionChecker::has_collision(seg, c);
            assertTrue(res);            
        }
        {
            Segment seg;
            seg.start = Vector(-1, 1.5);
            seg.end = Vector(1, 1.5);
            Circle c;
            c.center = Vector(0, 0.5);
            c.radius = 0.3f;
            bool res = CollisionChecker::has_collision(seg, c);
            assertTrue(!res);            
        }
        {
            bool res = CollisionChecker::is_point_inside_polygon(Vector(0.5f, 0.5f), square);
            assertTrue(res);            
        }
        {
            bool res = CollisionChecker::is_point_inside_polygon(Vector(1.5f, 0.5f), square);
            assertTrue(!res);            
        }
        {
            bool res = CollisionChecker::is_point_inside_polygon(Vector(1.f, 0.5f), square);
            assertTrue(res);            
        }
    }
}

